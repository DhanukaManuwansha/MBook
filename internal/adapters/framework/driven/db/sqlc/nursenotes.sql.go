// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: nursenotes.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addNurseNote = `-- name: AddNurseNote :one
INSERT INTO "NurseNotes" ( "remark", "nursing_care", "notes_datetime", "created_at", "nurse_id", "patient_id")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING "nursingnotes_id"
`

type AddNurseNoteParams struct {
	Remark        string         `json:"remark"`
	NursingCare   sql.NullString `json:"nursing_care"`
	NotesDatetime sql.NullTime   `json:"notes_datetime"`
	CreatedAt     time.Time      `json:"created_at"`
	NurseID       int64          `json:"nurse_id"`
	PatientID     string         `json:"patient_id"`
}

func (q *Queries) AddNurseNote(ctx context.Context, arg AddNurseNoteParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addNurseNote,
		arg.Remark,
		arg.NursingCare,
		arg.NotesDatetime,
		arg.CreatedAt,
		arg.NurseID,
		arg.PatientID,
	)
	var nursingnotes_id int64
	err := row.Scan(&nursingnotes_id)
	return nursingnotes_id, err
}

const getAllNurseNotes = `-- name: GetAllNurseNotes :many
SELECT nursingnotes_id, remark, nursing_care, notes_datetime, created_at, nurse_id, patient_id FROM "NurseNotes"
WHERE "patient_id"=$1
ORDER BY "nursingnotes_id"
`

func (q *Queries) GetAllNurseNotes(ctx context.Context, patientID string) ([]NurseNotes, error) {
	rows, err := q.db.QueryContext(ctx, getAllNurseNotes, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NurseNotes
	for rows.Next() {
		var i NurseNotes
		if err := rows.Scan(
			&i.NursingnotesID,
			&i.Remark,
			&i.NursingCare,
			&i.NotesDatetime,
			&i.CreatedAt,
			&i.NurseID,
			&i.PatientID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNurseNotes = `-- name: GetLatestNurseNotes :many
SELECT "NurseNotes".remark, "NurseNotes".nursing_care,"NurseNotes".notes_datetime, "NurseNotes".created_at, "User".user_name
FROM "NurseNotes" INNER JOIN "Nurse"
on "Nurse".nurse_id = "NurseNotes".nurse_id
INNER JOIN "User"
on "Nurse".user_id = "User".user_id
WHERE "patient_id" = $1
ORDER BY "created_at" DESC
LIMIT 14
`

type GetLatestNurseNotesRow struct {
	Remark        string         `json:"remark"`
	NursingCare   sql.NullString `json:"nursing_care"`
	NotesDatetime sql.NullTime   `json:"notes_datetime"`
	CreatedAt     time.Time      `json:"created_at"`
	UserName      string         `json:"user_name"`
}

func (q *Queries) GetLatestNurseNotes(ctx context.Context, patientID string) ([]GetLatestNurseNotesRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestNurseNotes, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestNurseNotesRow
	for rows.Next() {
		var i GetLatestNurseNotesRow
		if err := rows.Scan(
			&i.Remark,
			&i.NursingCare,
			&i.NotesDatetime,
			&i.CreatedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNurseNote = `-- name: UpdateNurseNote :one
UPDATE "NurseNotes"
SET "remark" = $2, "nursing_care" = $3, "notes_datetime" = $4 ,  "nurse_id" = $5, "patient_id" = $6
WHERE "nursingnotes_id" = $1
RETURNING nursingnotes_id, remark, nursing_care, notes_datetime, created_at, nurse_id, patient_id
`

type UpdateNurseNoteParams struct {
	NursingnotesID int64          `json:"nursingnotes_id"`
	Remark         string         `json:"remark"`
	NursingCare    sql.NullString `json:"nursing_care"`
	NotesDatetime  sql.NullTime   `json:"notes_datetime"`
	NurseID        int64          `json:"nurse_id"`
	PatientID      string         `json:"patient_id"`
}

func (q *Queries) UpdateNurseNote(ctx context.Context, arg UpdateNurseNoteParams) (NurseNotes, error) {
	row := q.db.QueryRowContext(ctx, updateNurseNote,
		arg.NursingnotesID,
		arg.Remark,
		arg.NursingCare,
		arg.NotesDatetime,
		arg.NurseID,
		arg.PatientID,
	)
	var i NurseNotes
	err := row.Scan(
		&i.NursingnotesID,
		&i.Remark,
		&i.NursingCare,
		&i.NotesDatetime,
		&i.CreatedAt,
		&i.NurseID,
		&i.PatientID,
	)
	return i, err
}
